这是我们已经发现的一些问题，需要以后逐一修改：

- [x] 我们的页面学习量由 1000 页降到 100 页，所有文案和逻辑已同步。
- [x] 推荐任务看起来没有定时执行，根据我们的设计，应该每次推荐一条，这个任务间隔可以短一些。
  - 已添加 `generate-recommendation` 定时器，每 20 分钟生成 1 条推荐
- [x] 推理分析现在会将整篇推理输出到日志，我们已经确信推理可以工作了，就不需要输出这个推理了
  - 已修改为只记录推理内容长度，不输出完整内容
- [x] 我们有 storage 和 stores 两个类似的目录？
  - 分析结论：职责不同，不需要合并
    - `storage/`: IndexedDB 数据库层 (Dexie) + 配置持久化 (chrome.storage)
    - `stores/`: React UI 状态管理 (Zustand)
- [x] UI 文案问题（已修复 2025-11-19）
  - 设置页底部显示 `静阅 - 静阅` 重复 → 改为 `Silent Feed (静阅)`
  - 弹窗页标题显示两个"静阅" → 副标题改为显示 slogan `让信息流安静下来`
  - 欢迎标语太普通 → 改为产品 slogan
  - 提示文字过长换行 → 精简为`开始浏览，自动学习你的兴趣`
- [x] UI 布局优化（已修复 2025-11-19）
  - "让信息流安静下来" 出现两次 → 去掉头部副标题，只在欢迎语显示
  - 欢迎语改为更温暖的"开始你的阅读之旅"
  - 学习提示改为"我会在后台学习你的兴趣"
  - 应用名改为居中显示
- [x] 推荐文章时，如果该文章太老，就不需要分析和推荐，以防有些 RSS 会将很老的文章也列入（已修复 2025-11-19）
  - 在 pipeline.ts 中添加 30 天过滤逻辑
- [x] 在学习阶段，分析配置中的智能推荐数量，应该为 0，并说明在探索学习阶段不推荐（已修复 2025-11-19）
  - 在 CollectionStats.tsx 中添加学习阶段检测
  - 显示推荐数量为 0 并说明暂不推荐
- [x] 发现 RSS 后，点击雷达图标应该直接进到设置页的订阅源标签（已修复 2025-11-22）
  - RSSDiscoveryHint.tsx 中的 URL 从 #rss 改为 #feeds
  - ColdStartView.tsx 中的 URL 从 #rss 改为 #feeds
- [x] 手绘风格下，RSS/ATOM 和语言标签字体未使用手绘风格（已修复 2025-11-22）
  - RSSSettings 组件添加 isSketchyStyle prop 支持
  - RSS/ATOM 徽章和语言标签根据主题动态应用 sketchy-text 类
  - 统一标签尺寸为 text-xs（从 text-[10px] 改为 text-xs）
- [x] 弹窗雷达图标点击问题和手绘风格布局拥挤（已修复 2025-11-22）
  - 标准风格下雷达图标现在也可点击跳转到 Feeds 标签
  - 统一手绘和标准风格使用相同的圆环进度布局
  - CircularProgress 组件添加 isSketchyStyle、onIconClick、iconClickable 支持
  - 移除手绘风格拥挤的旧布局，保留手绘视觉样式（sketchy-emoji、sketchy-text、sketchy-badge、sketchy-card）
- [x] 在学习阶段，扩展图标不能在显示了其它状态后恢复到阴影覆盖表示学习进度的样式（已修复 2025-11-22）
  - 修复 IconManager 在停止动画后未重置 currentState 的问题
  - stopDiscoverAnimation() 和 stopFetchingAnimation() 现在会将状态重置为 'static'
  - updateIcon() 能正确根据当前实际情况（学习进度/推荐数）显示对应状态
- [x] 弹窗内的条目在点击某条不想读之后，新填充的条目并不是按推荐比例倒序排列的。（已修复 2025-11-24）
  - 在 dismissSelected() 和 markAsRead() 中添加排序逻辑
  - 获取 maxRecommendations * 2 条推荐后按 score 倒序排列再切片
  - 与 loadRecommendations() 保持一致的排序行为
- [x] "❌ 推荐生成失败: 没有可用的RSS文章数据，请先订阅一些RSS源"这个消息不应该是错误，而应该是一个不打扰用户的警告，可以在弹窗里面的所有推荐条目全部消失后，要么推荐用户手动分析，要么告知用户没有足够的 RSS。（已修复 2025-11-24）
  - RecommendationService 返回空结果和提示信息，而非抛出错误
  - recommendationStore 区分"无数据"和"真实错误"
  - 无数据时不设置 error 状态，让 UI 显示友好的空状态引导
  - 用户可选择"立即生成推荐"或继续浏览
- [x] 验证 RSS 源时，如果 404 找不到，直接略过，无需报错（已修复 2025-11-28）
  - background.ts: 将 404 等错误从 "❌ 验证失败" 改为 "验证失败，已跳过"
  - 移除干扰性的错误图标，静默跳过无效源
- [x] 标准风格下，弹窗在学习阶段的设置按钮宽度太宽，占满了弹窗宽度（已修复 2025-11-25）
  - 移除标准风格设置按钮的 w-full 类
  - 添加居中布局 flex justify-center
  - 调整按钮 padding 为 px-6（从 px-4）
- [x] 本地 Ollama 返回 403 错误（已修复 2025-11-27）
  - **根本原因**: Ollama 默认拒绝 `chrome-extension://` 来源的 CORS 请求
  - **验证**: `curl -H "Origin: chrome-extension://test" http://localhost:11434/api/tags` 返回 403
  - **解决方案**: 使用 declarativeNetRequest API 移除 Origin 和 Referer 请求头
  - **实现**: 创建 `public/dnr-rules.json` 配置 DNR 规则，自动移除本地 AI 请求的 CORS 头
  - **参考**: yesterday 项目提交 6a21608 "终于让后台支持了 ollama"
  - **优势**: 
    - 无需修改 Ollama 服务器配置
    - 无需用户手动配置环境变量
    - 使用 MV3 标准 API（declarativeNetRequest）
    - 比 webRequest 更高效且不需要 blocking 权限
- [x] 用户画像现在不能显示，文字都是国际化字符串（已修复 2025-11-28）
  - 在 zh-CN/translation.json 添加 userProfile.chat 翻译
  - 在 en/translation.json 添加对应英文翻译
  - 修复国际化占位符解析问题
- [x] ollama 引擎的调试日志和优化（已修复 2025-11-28）
  - **调试日志清理**:
    - recommendation-config.ts: 删除 "Ollama未检测到（正常）" debug 日志
    - analysis-engine-capability.ts: 删除 "Ollama 不可用（正常）" debug 日志
    - OllamaProvider.ts: 删除 curl 命令调试日志（等效 curl 命令、URL、Headers、Body）
  - **DNR 配置修复**:
    - 问题: npm run dev 时 DNR 配置未正确应用到 manifest.json，导致 403 错误
    - 根本原因: package.json 的 dev 脚本中 setup-dnr.sh 执行时机不对
    - 解决方案: 创建 watch-dnr.sh 脚本监听构建目录，自动配置 DNR
    - 修改: package.json dev 脚本改为 `bash scripts/watch-dnr.sh & plasmo dev`
  - **模式切换优化**:
    - 问题: callChatAPI 在错误时会跨模式重试（legacy ↔ openai）
    - 优化: isAvailable() 初始化时已测试并确定最佳模式，callChatAPI 直接使用
    - 保留: legacy 模式内的 /api/chat → /api/generate 降级（合理功能）
    - 移除: 跨模式 fallback 重试，避免不必要的延迟
- [x] AI 配置浮层测试后，点击 AI 卡片检测按钮报错（已修复 2025-12-01）
  - **Bug #18**: 配置浮层测试成功后，点击 AI 卡片检测报错"未配置 AI 提供商"
  - **根本原因**: 配置多个 provider 时，全局 model 和 enableReasoning 被后配置的覆盖
    - 配置 DeepSeek 后配置 OpenAI，config.model 被覆盖为 OpenAI 的模型
    - 检测 DeepSeek 时读取到 OpenAI 的 model，导致 API 调用失败
  - **解决方案**: 重构配置结构（Phase 9.2）
    - 新增 RemoteProviderConfig interface: `{ apiKey, model, enableReasoning }`
    - 更新 AIConfig interface，新增 `providers: { deepseek?, openai? }` 字段
    - 保留旧字段标记为 @deprecated，确保向后兼容
  - **数据迁移**:
    - getAIConfig: 自动将旧结构（apiKeys + model）迁移到新结构（providers）
    - saveAIConfig: 双写新旧结构，确保平滑过渡
  - **代码更新**:
    - AIConfigPanel.tsx: 从 providers[providerId] 读取和保存配置
    - useAIProviderStatus.ts: 从 providers[providerId] 读取配置进行检测
    - AICapabilityManager.ts: 从 providers 结构初始化
  - **影响范围**: 11 个文件，+999/-134 行代码
  - **测试**: 所有测试通过 (1401 passed, 1 skipped)
  - **关联文档**: docs/BUG_FIX_AI_CONFIG_SAVE.md
- [x] AI 引擎下的 AI 提供商的配置浮层的遮蔽层没有放在整个视口，配置浮层也没相应居中到中间。——这是一个回归的错误。（已修复 2025-12-01）
  - **Bug #19**: 成本参考浮层未使用 createPortal，导致无法覆盖整个视口
  - **根本原因**: showCostDetails 浮层直接渲染在组件内，而不是 document.body
  - **解决方案**: 使用 createPortal(浮层内容, document.body) 将浮层挂载到 body
  - **修复文件**: src/components/settings/AIConfig.tsx
- [x] 重构了 AI 配置结构后，出现报错：（已修复 2025-12-01）
  - **Bug #20**: `InvalidCharacterError: Failed to execute 'atob' on 'Window'`
  - **根本原因**: 
    1. AIConfig.tsx 保存时只使用 apiKeys（旧结构），未使用 providers（新结构）
    2. saveAIConfig 从 providers 读取并加密明文 API key
    3. 下次读取时再次解密，导致对明文 Base64 编码的 API key 进行 atob 解码失败
  - **解决方案**:
    1. AIConfig.tsx 保存时同时构建 providers 结构，包含解密后的 API key
    2. decryptApiKey 增加检查：如果输入不是 Base64 格式（如 sk-xxx），直接返回不解密
  - **修复文件**: 
    - src/components/settings/AIConfig.tsx（保存逻辑 - 保留现有 provider 配置）
    - src/components/AIConfigPanel.tsx（导入 createPortal、使用 createPortal、测试保存逻辑）
    - src/storage/ai-config.ts（解密逻辑 - 检查 Base64 格式）
  - **详细修复**:
    1. **配置浮层覆盖层问题**:
       - AIConfigPanel.tsx 导入 createPortal
       - ConfigModal 使用 `createPortal(<ConfigModal />, document.body)` 挂载到 body
    2. **API Key 双重加密问题**:
       - decryptApiKey 增加 Base64 格式检测（正则 `/^[A-Za-z0-9+/]*={0,2}$/`）
       - 非 Base64 格式直接返回，避免对明文 API key 执行 atob
    3. **测试保存覆盖问题**（新发现）:
       - AIConfigPanel.tsx 测试成功后保存时，不再设置全局的 model/provider/enableReasoning
       - 只更新 providers 结构中特定 provider 的配置
    4. **自动保存覆盖问题**（新发现）:
       - AIConfig.tsx 自动保存时，先从 storage 读取现有的 providers 配置
       - 只更新有 API key 的 providers，保留其他 provider 的 model 和 enableReasoning
       - 对于当前 provider，使用当前选择的 model 和 enableReasoning
       - 对于其他 providers，保留原有配置，只更新 apiKey
  - **测试**: 所有测试通过 (1401 passed, 1 skipped)
- [x] AI 配置浮层中，各个模型的说明没有国际化（已修复 2025-12-01）
  - **Bug #21**: AIConfigPanel 中模型选择使用硬编码的 model.name 和 model.description
  - **问题**: 模型名称和描述没有使用国际化，无法支持多语言
  - **解决方案**:
    - AIConfigPanel.tsx: 使用 `_(options.aiConfig.models.${model.id}.name)` 和 `description`
    - 补充 o4-mini 模型的国际化翻译（中英文）
  - **修复文件**:
    - src/components/AIConfigPanel.tsx（使用国际化）
    - public/locales/zh-CN/translation.json（添加 o4-mini 翻译）
    - public/locales/en/translation.json（添加 o4-mini 翻译）
  - **测试**: 所有测试通过 (1401 passed, 1 skipped)
- [ ] ```
 [LocalAIEndpoint] legacy 接口返回 2 个模型
 [LocalAIEndpoint] ✅ 成功获取 2 个模型: deepseek-llm:7b, llama3.1:latest
 [ErrorHandler] [AIConfig.decryptApiKey] 操作失败: InvalidCharacterError: Failed to execute 'atob' on 'Window': The string to be decoded is not correctly encoded.
    at tag (ai-config.ts:408:7)
    at withErrorHandlingSync (error-handler.ts:122:12)
    at decryptApiKey (ai-config.ts:405:21)
    at tag (ai-config.ts:238:15)
    at async withErrorHandling (error-handler.ts:72:12)
    at async saveEngineAssignment (ai-config.ts:516:9)
    at async AIConfig.tsx:378:16
error @ options.526298b9.js:40044了解此错误
 [AIConfig] Failed to decrypt API key, using as-is 
warn @ options.526298b9.js:40039了解此警告
 [RecommendationConfig] 配置已保存: Object
```