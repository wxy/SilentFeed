# AI 宪法重构方案（最终版）

## 🎯 架构决策确认

### 1. 新的三层结构 ✅
```
Part 1: 核心原则
Part 2: 强制执行规则（4 项）
Part 3: 执行前检查协议（6 步）
Part 4: 技能激活体系
Part 5: 通用角色与对话风格
```

### 2. _evolution-core 为条件强制 ✅
- 自动检测重复错误、用户反馈、复杂工作流
- 当条件满足时，主动提议改进
- 不需要用户显式请求

### 3. 技能的模块化架构 ✅ **（核心创新）**
**原则**：技能的依赖关系、触发条件、前置检查应该**内置于技能内部**，而非由宪法决定。

**优势**：
- 当添加新技能时，只需定义该技能的依赖，无需修改宪法
- 技能是自包含的模块，可独立维护
- 避免宪法成为"依赖中枢"，减少维护成本
- 支持动态扩展：新技能可以自动集成到系统中

### 4. 条件触发前询问用户 ✅
- **自动触发**：_evolution-core 检测到条件时自动启动
- **用户确认**：在执行任何修改前（如修改宪法、创建/更新技能），明确询问用户
- **模式**：
  ```
  检测到重复错误/用户反馈
    ↓
  _evolution-core 分析并提出方案
    ↓
  询问用户："我建议执行 X，你同意吗？"
    ↓
  基于用户确认执行修改
  ```

---

## 📐 新的技能定义规范

### 技能文件的新格式（SKILL.md）

```markdown
---
name: <skill-name>
description: <brief description>
tier: [1|2|3]
# Tier 1: 强制执行（每次回复）
# Tier 2: 条件强制（自动触发）
# Tier 3: 显式请求（用户明确要求）
---

# <Skill Name>

## 基本信息

### 触发条件（何时激活）
- **条件类型**：[自动|显式请求|条件]
- **具体条件**：...

### 前置依赖（执行前必须满足）
- **强制依赖**：
  - <skill-name>（必须在本技能前执行）
  - ...
- **可选依赖**：
  - <skill-name>（如果存在则建议执行）
  - ...

### 执行顺序约束
- **应该在...之前**：
- **应该在...之后**：
- **可以与...并行**：

---

## 详细说明

[原有的技能内容]

---

## 集成说明

### 何时被激活
- 当满足"触发条件"时自动/显式激活

### 依赖检查
```python
# 伪代码示例
if self.trigger_condition_met():
    for dependency in self.strong_dependencies:
        ensure_skill_executed(dependency)
    self.execute()
    for post_hook in self.post_hooks:
        post_hook()  # 可选的后续清理
```

### 用户交互点
- 在执行修改前询问用户确认
- 示例确认消息：
  ```
  我建议基于以下原因更新 <resource>：
  - 原因 1
  - 原因 2
  
  你同意吗？[是/否]
  ```

---

## 注意事项
- 技能应该是自包含的，不依赖全局宪法中的条件判断
- 依赖关系应该被清晰声明，便于工具自动分析（如生成执行图）
```

---

## 📋 宪法重构的具体改动

### Part 1: 核心原则（精简版，删除重复）

**保留内容**：
- 持续学习与自我改进（简化）
- 进化的触发条件（表格保留）
- 技能系统与指令的关系（新增：说明技能的模块化原则）

**删除内容**：
- 关于"技能系统"的详细描述（移到 Part 4）
- 关于"指令"的详细描述（现在通过指令文件本身说明）

**新增内容**：
```markdown
### 技能的模块化原则
- 技能是自包含的模块，内部定义自己的：
  - 触发条件
  - 前置依赖（强制和可选）
  - 执行约束
- 宪法不决定技能的依赖关系，而是提供"激活框架"
- 新技能可以随时添加，无需修改宪法的依赖表
```

---

### Part 2: 强制执行规则（简化，4 项不变）

**改动**：
- 每项规则只保留"是什么"和"为什么"，去掉过度的细节
- 具体的执行细节委托给 Part 3 的"执行前检查协议"
- 删除与 Part 3 的重复描述

---

### Part 3: 执行前检查协议（核心协议，6 步 + 补救）

**来源**：从现有的"规则 5"扩展而来

**结构**：
```
## 执行前检查协议

### 概述
在每次生成回复前，必须执行本协议的 6 步检查...

### 6 步执行流程
1. 指令加载检查
2. 强制规则加载检查（与 Part 2 交叉引用）
3. 输出格式检查
4. 风险评估检查
5. 真相检验
6. 检查失败的补救

### 补救与自我纠正机制
[现有的 5.6 内容]

### 输出验证清单
[现有的内容]

### 常见失败模式与修正
[现有的表格]
```

---

### Part 4: 技能激活体系（重构，模块化架构）

**新结构**：

```markdown
## 技能激活体系

### 激活框架（3 层）

#### Tier 1: 强制执行（每次回复必须执行）
- 这些技能在每次回复前自动激活
- 由 _execution-precheck 协议触发
- 清单：
  - _instruction-guard
  - _context-ack
  - _file-output-guard
  - _session-safety

#### Tier 2: 条件强制（自动触发，遇到条件立即激活）
- 这些技能在特定条件满足时自动激活
- **不需要**用户显式请求
- **每个技能内部定义自己的触发条件和依赖**
- 清单：
  - _evolution-core（检测到重复错误/用户反馈/复杂工作流）
  - _code-health-check（代码修改准备提交时）
  - _typescript-type-safety（编写/修改 TS 代码时）

#### Tier 3: 显式请求（用户明确要求时激活）
- 这些技能**仅在用户明确请求时**激活
- **每个技能内部定义自己的依赖关系**
- 清单：
  - _git-commit（用户请求提交）
  - _pr-creator（用户请求创建 PR）
  - _skills-manager（用户请求管理技能）
  - _release-process（用户请求发布）

### 关键说明
- **依赖关系内置于技能**：每个技能的 SKILL.md 中声明其前置依赖和执行约束
- **宪法不维护依赖表**：避免宪法成为"依赖中枢"，遵循模块化原则
- **用户交互点**：Tier 2 和 Tier 3 在执行任何修改前应询问用户确认

### 技能的通用执行流程

每个技能（尤其是 Tier 2-3）应该遵循以下流程：

```
1. 检查前置依赖是否满足
   ├─ 强制依赖：如未执行，先执行依赖
   └─ 可选依赖：如存在则执行，不存在则跳过

2. 检查触发条件
   ├─ 条件满足 → 继续
   └─ 条件不满足 → 结束（不执行）

3. 分析并提出改进方案
   ├─ 对于 Tier 2-3：询问用户确认
   │   "我建议执行 X，理由是 Y，你同意吗？"
   └─ 等待用户反馈

4. 基于确认执行
   ├─ 用户同意 → 执行改进
   └─ 用户拒绝 → 记录为"已评估但用户拒绝"

5. 记录结果
   └─ 便于后续 Tier 2 的重复检测
```

### 示例：_evolution-core 的自包含依赖定义

```markdown
---
name: _evolution-core
tier: 2
---

## 触发条件
- 检测到同一会话或多个会话中的重复错误
- 用户明确指出行为不符合预期
- 某类任务反复耗时或高风险

## 前置依赖
- **强制依赖**：无（_evolution-core 本身是元技能）
- **可选依赖**：_execution-precheck（确保检查机制已激活）

## 执行约束
- **应该在...之前**：生成最终回复
- **应该在...之后**：识别问题或收到用户反馈

## 用户交互点
在提议修改宪法或创建/更新技能前，询问用户：
```
我检测到以下情况：
- [描述错误/反馈]

建议方案：
- [方案 A]
- [方案 B]

你希望采取哪个方案？
```
```

---

### Part 5: 通用角色与对话风格（保持不变）

---

## 🔧 实施步骤

### 第 1 步：创建新的宪法文档
- 使用上述结构重新组织内容
- 删除所有重复内容
- 在 Part 4 中只列出技能清单，不维护依赖表

### 第 2 步：更新现有技能文件
对以下技能进行更新（添加 Tier 和依赖声明）：
- [ ] _instruction-guard → 添加 tier: 1, 触发条件, 依赖声明
- [ ] _context-ack → 添加 tier: 1, 触发条件, 依赖声明
- [ ] _file-output-guard → 添加 tier: 1, 触发条件, 依赖声明
- [ ] _session-safety → 添加 tier: 1, 触发条件, 依赖声明
- [ ] _execution-precheck → 改为 tier: 1，调整依赖声明
- [ ] _evolution-core → 改为 tier: 2，添加用户交互点说明
- [ ] _code-health-check → 改为 tier: 2，添加触发条件和用户交互
- [ ] _typescript-type-safety → 改为 tier: 2，添加触发条件
- [ ] _git-commit → 改为 tier: 3，添加依赖声明
- [ ] _pr-creator → 改为 tier: 3，添加依赖关系
- [ ] _skills-manager → 改为 tier: 3，添加依赖声明
- [ ] _release-process → 改为 tier: 3，添加依赖关系
- [ ] _change-summary → 检查 tier，添加依赖声明
- [ ] _traceability-check → 检查 tier，添加依赖声明

### 第 3 步：创建技能定义规范文档
- 编写 `.evolution-skills/SKILL_DEFINITION_SPECIFICATION.md`
- 这是所有技能文件应该遵循的格式规范

### 第 4 步：更新项目指令
- `.github/copilot-instructions.md` Part 1 指向新的宪法结构
- 突出"技能的模块化原则"和"用户交互点"

### 第 5 步：提交并创建 PR
- 将所有改动提交到 `feat/ai-execution-precheck` 分支
- 创建 PR，等待用户审阅

---

## 📊 改动影响评估

### 对现有工作流的影响
- ✅ **正面**：
  - 宪法更清晰，易于理解和维护
  - 技能真正模块化，支持动态扩展
  - 用户有更多的控制权（确认改进方案）
  - 避免宪法成为"依赖中枢"，减少维护成本

- ⚠️ **需要适应的变化**：
  - Tier 2 的条件触发需要自动检测逻辑（可通过 _evolution-core 实现）
  - 需要在 Tier 2-3 技能执行前增加用户询问机制

### 向后兼容性
- ✅ 现有的 Tier 1 技能（强制执行）无需修改核心逻辑
- ✅ Tier 3 的显式请求技能兼容现有用法
- ⚠️ Tier 2 的自动触发需要新的交互模式（用户确认）

---

## ✅ 重构完成标志

- [ ] 新宪法文档已创建并包含 5 Part 结构
- [ ] 所有重复内容已删除
- [ ] 技能清单已更新，包含 Tier 和依赖声明
- [ ] 技能定义规范文档已创建
- [ ] 现有技能文件已按新规范更新
- [ ] 项目指令已更新
- [ ] PR 已创建并准备审阅
